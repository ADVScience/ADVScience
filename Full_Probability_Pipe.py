"""Law of large numbers"""
import numpy as np
import matplotlib.pyplot as plt
import seaborn

"""Создадим список серий с количеством испытаний в каждой из них. 
Для этого нам потребуется массим с экспоненциальным увеличением количества испытаний от серии к серии."""

series = np.logspace(1, 6, dtype = 'int')

# обозначим точку отсчета
np.random.seed(5)

# во внешнем цикле пройдемся по сериям испытаний (их будет 50)
for i, trial in enumerate(series, 1):

    # выведем серию и количество бросков внутри нее
    print(f'Серия: {i}, количество испытаний: {trial}\n')

    # во внутреннем цикле будем бросать кость
    for n in range(trial):
        # запишем результат каждого броска
        result = np.random.randint(1, 7)

        # выведем номер броска и соответствующий результат
        print(f'Испытание: {n}, выпало число: {result}')

    # прервемся после первой серии
    break

# создадим счетчик для количества успешных испытаний
success = 0

# сохраняем ту же точку отсчета
np.random.seed(5)

# Теперь в двух циклах пройдемся по сериям и броскам в каждой серии
for trial in series:
    for n in range(trial):
        result = np.random.randint(1, 7)

        # если результат будет равен двум или трем
        if result == 2 or result == 3:
            # обновим счетчик
            success += 1

    # в конце каждой серии посчитаем долю успешных испытаний
    prob = success / trial

    print(f'Серия: {i}\n')  # и выведем номер серии,
    print(f'Всего испытаний: {trial}')  # общее количество испытаний,
    print(f'Успешных исходов: {success}')  # количество и
    print(f'Теоретическая вероятность: {0.33}, а Эмпирическая вероятность: {prob}\n\n')  # долю успешных испытаний

    # прервемся после окончания первой серии
    break

# сохраняем ту же точку отсчета
np.random.seed(5)

# создадим счетчик для испытаний в каждой серии
success = 0

# а также создадим список для записи результатов в пределах одной серии
prob_list = []

# пройдемся по сериям
for trial in series:

    # и броскам в каждой серии
    for n in range(trial):
        result = np.random.randint(1, 7)

        # посчитаем количество успешных бросков
        if result == 2 or result == 3:
            success += 1

    # вычислим долю успешных бросков
    prob = success / trial

    # добавим результат серии в список
    prob_list.append(prob)

    # обнулим счетчик для записи результата следующей серии
    success = 0

# после проведения всех серий испытаний выведем их количество
print(f'Проведено серий испытаний: {len(prob_list)}\n\n')

# а также эмпирическую вероятность отдельных серий
print(f'Эмпирическая вероятность каждой пятой серии: {np.round(prob_list[::5], 2)}')



# зададим размер графика и стилизацию
plt.figure(figsize=(10, 8))
seaborn.set_theme(context='notebook', style='darkgrid', palette='deep', 
                  font='sans-serif', font_scale=1, color_codes=True, rc=None)

# выведем горизонтальную линию теоретической вероятности
plt.axhline(y=1 / 3, c='r')

# а также эмпирическую вероятность по результатам 50-ти серий испытаний
plt.plot(prob_list)

# добавим подписи к осям
plt.xlabel('Серии', fontsize=16)
plt.ylabel('Вероятность', fontsize=16)

"""Теперь мы видим, что если в первых сериях эмпирическая вероятность могла довольно сильно отличаться от теоретической,
то с увеличением количества бросков она вплотную приблизилась к 1/3.
В результате данная программа позволяет наглядно убедиться в верности Закона больших чисел (Law of large numbers) с помощью метода Монте-Карло."""

"""Пример кода ниже позволяет сократить время расчета более чем в 300 раз за счет использования векторизации"""

np.random.seed(5)
 
# создадим новый список для записи результатов 
prob_list_2 = []
 
# пройдемся по каждой из 50-ти серий
for trial in series:
 
  # вместо второго цикла, передадим количество бросков 
  # непосредственно в функцию np.random.randint()
  result = np.random.randint(1, 7, trial)
 
  # в переменную success запишем сумму выпавших двоек или троек из массива result
  success = (result == 2).sum() + (result == 3).sum()
 
  # посчитаем долю успешных исходов
  prob = success / trial
 
  # и запишем ее в список
  prob_list_2.append(prob)
 
#Увебимся, что получили тот же самый результат:
print(f'Эмпирическая вероятность каждой пятой серии:{np.round(prob_list_2[::5], 2)}')

